function net = ELFCnnInitNetwork4(nLabel, nFeatureDim, useGpu)

%%
net.type = 'cnn';
net.class = [];
net.layers = {} ;

scal = 1 ;
init_bias = 0.1;


% 1 conv1
net.layers{end+1} = struct('type', 'conv', ...
    'filters', 0.01/scal * randn(41, 41, nFeatureDim, 50, 'single'), ...
    'biases', zeros(1, 50, 'single'), ...
    'filtersLearningRate', 1, ...
    'biasesLearningRate', 2, ...
    'filtersWeightDecay', 1.5, ...
    'biasesWeightDecay', 0, ...
    'stride', 3, ...
    'pad', 0) ;

% 2 pool1 (max pool)
net.layers{end+1} = struct('type', 'pool', ...
    'method', 'max', ...
    'pool', [2 2], ...
    'stride', 2, ...
    'pad', 0) ;

% 3 relu1
net.layers{end+1} = struct('type', 'relu') ;

% 4 conv2
net.layers{end+1} = struct('type', 'conv', ...
    'filters', 0.01/scal * randn(21, 21, 50, 128, 'single'),...
    'biases', init_bias*zeros(1,128,'single'), ...
    'filtersLearningRate', 1, ...
    'biasesLearningRate', 2, ...
    'filtersWeightDecay', 1.5, ...
    'biasesWeightDecay', 0,...
    'stride', 1, ...
    'pad', 0) ;

% 5 relu2
net.layers{end+1} = struct('type', 'relu') ;
net.layers{end+1} = struct('type', 'dropout', ...
                           'rate', 0.1) ;
% 6 pool2 (avg pool)
net.layers{end+1} = struct('type', 'pool', ...
    'method', 'avg', ...
    'pool', [2 2], ...
    'stride', 2, ...
    'pad', 0) ;


% 10 ip1
net.layers{end+1} = struct('type', 'conv', ...
    'filters', 0.1*randn(1, 1, 128, 800, 'single'),...
    'biases', init_bias*zeros(1, 800, 'single'), ...
    'filtersLearningRate', 1, ...
    'biasesLearningRate', 2, ...
    'filtersWeightDecay', 1.5, ...
    'biasesWeightDecay', 0,...
    'stride', 1, ...
    'pad', 0) ;

% 11 ip2
net.layers{end+1} = struct('type', 'conv', ...
    'filters', 0.1*randn(1, 1, 800, nLabel, 'single'),...
    'biases', zeros(1, nLabel,'single'), ...
    'filtersLearningRate', 1, ...
    'biasesLearningRate', 2, ...
    'filtersWeightDecay', 1.5, ...
    'biasesWeightDecay', 0,...
    'stride', 1, ...
    'pad', 0) ;
% 12 loss
net.layers{end+1} = struct('type', 'softmaxloss') ;


%%
% Other details
net.normalization.interpolation = 'bicubic' ;
net.normalization.averageImage = [] ;
net.normalization.keepAspect = true ;
% 为什么有3组learning rate
net.learningRate = [0.001*ones(1, 12) 0.0001*ones(1,6) 0.00001] ;
% 记录运行时的learning rate
net.lr = 0;
net.weightDecay = 0.0005;
net.momentum = 0.9;

for i=1:numel(net.layers)
  if ~strcmp(net.layers{i}.type,'conv'), continue; end
  net.layers{i}.filtersMomentum = zeros(size(net.layers{i}.filters), ...
    class(net.layers{i}.filters)) ;
  net.layers{i}.biasesMomentum = zeros(size(net.layers{i}.biases), ...
    class(net.layers{i}.biases)) ; %#ok<*ZEROLIKE>
  if ~isfield(net.layers{i}, 'filtersLearningRate')
    net.layers{i}.filtersLearningRate = 1 ;
  end
  if ~isfield(net.layers{i}, 'biasesLearningRate')
    net.layers{i}.biasesLearningRate = 1 ;
  end
  if ~isfield(net.layers{i}, 'filtersWeightDecay')
    net.layers{i}.filtersWeightDecay = 1 ;
  end
  if ~isfield(net.layers{i}, 'biasesWeightDecay')
    net.layers{i}.biasesWeightDecay = 1 ;
  end
end

if useGpu
  net = vl_simplenn_move(net, 'gpu') ;
  for i=1:numel(net.layers)
    if ~strcmp(net.layers{i}.type,'conv'), continue; end
    net.layers{i}.filtersMomentum = gpuArray(net.layers{i}.filtersMomentum) ;
    net.layers{i}.biasesMomentum = gpuArray(net.layers{i}.biasesMomentum) ;
  end
end